;#include <io.h>
;PCODE: $00000000 VOL: 0
	#ifndef __SLEEP_DEFINED__
;PCODE: $00000001 VOL: 0
	#define __SLEEP_DEFINED__
;PCODE: $00000002 VOL: 0
	.EQU __se_bit=0x80
;PCODE: $00000003 VOL: 0
	.EQU __sm_mask=0x70
;PCODE: $00000004 VOL: 0
	.EQU __sm_powerdown=0x20
;PCODE: $00000005 VOL: 0
	.EQU __sm_powersave=0x30
;PCODE: $00000006 VOL: 0
	.EQU __sm_standby=0x60
;PCODE: $00000007 VOL: 0
	.EQU __sm_ext_standby=0x70
;PCODE: $00000008 VOL: 0
	.EQU __sm_adc_noise_red=0x10
;PCODE: $00000009 VOL: 0
	.SET power_ctrl_reg=mcucr
;PCODE: $0000000A VOL: 0
	#endif
;PCODE: $0000000B VOL: 0
;PCODE: $0000000C VOL: 0
;//#include <avr/interrupt.h>
;//#include <util/delay.h>
;//#include <avr/pgmspace.h>   /* нужно дл€ usbdrv.h */
;#include <stdio.h>
;#include "usbdrv.c"
;/* Name: usbdrv.c
; * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
; * Author: Christian Starkjohann
; * Creation Date: 2004-12-29
; * Tabsize: 4
; * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
; * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
; */
;
;#include "usbdrv.h"

	.CSEG
;PCODE: $0000000D VOL: 0
;PCODE: $0000000E VOL: 0
	cli
;PCODE: $0000000F VOL: 0
;PCODE: $00000010 VOL: 0
;PCODE: $00000011 VOL: 0
;PCODE: $00000012 VOL: 0
;PCODE: $00000013 VOL: 0
	sei
;PCODE: $00000014 VOL: 0
;PCODE: $00000015 VOL: 0
;PCODE: $00000016 VOL: 0
;PCODE: $00000017 VOL: 0
;PCODE: $00000018 VOL: 0
;PCODE: $00000019 VOL: 0
;PCODE: $0000001A VOL: 0
;PCODE: $0000001B VOL: 0
;PCODE: $0000001C VOL: 0
;PCODE: $0000001D VOL: 0
;PCODE: $0000001E VOL: 0
;PCODE: $0000001F VOL: 0
;#include "oddebug.h"
;
;flash char usbHidReportDescriptor[22] = { // USB report descriptor         // ƒескриптор описывает структуру пакета данн ...
;    0x06, 0x00, 0xff,                       // USAGE_PAGE (Generic Desktop)
;    0x09, 0x01,                             // USAGE (Vendor Usage 1)
;    0xa1, 0x01,                             // COLLECTION (Application)
;    0x15, 0x00,                             //    LOGICAL_MINIMUM (0)        // min. значение дл€ данных
;    0x26, 0xff, 0x00,                       //    LOGICAL_MAXIMUM (255)      // max. значение дл€ данных, 255 тут не слу ...
;    0x75, 0x08,                             //    REPORT_SIZE (8)            // информаци€ передаетс€ порци€ми, это разм ...
;    0x95, 1,    //    REPORT_COUNT               // количество порций (у нашем примере = 3, описанна€ выше структура пер ...
;    0x09, 0x00,                             //    USAGE (Undefined)
;    0xb2, 0x02, 0x01,                       //    FEATURE (Data,Var,Abs,Buf)
;    0xc0                                    // END_COLLECTION
;};
;/* «десь мы описали только один report, из-за чего не нужно использовать report-ID (он должен быть первым байтом).
; * — его помощью передадим 3 байта данных (размер одного REPORT_SIZE = 8 бит = 1 байт, их количество REPORT_COUNT = 3).
; */
;
;/*
;General Description:
;This module implements the C-part of the USB driver. See usbdrv.h for a
;documentation of the entire driver.
;*/
;
;/* ------------------------------------------------------------------------- */
;
;/* raw USB registers / interface to assembler code: */
;uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
;uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
;uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
;uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
;uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
;volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
;uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
;uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
;volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */

	.DSEG
;uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
;#if USB_COUNT_SOF
;volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
;#endif
;#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
;usbTxStatus_t  usbTxStatus1;
;#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
;usbTxStatus_t  usbTxStatus3;
;#   endif
;#endif
;#if USB_CFG_CHECK_DATA_TOGGLING
;uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
;#endif
;
;/* USB status registers / not shared with asm code */
;usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
;static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
;static uchar        usbMsgFlags;    /* flag values see below */
;
;#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
;#define USB_FLG_USE_USER_RW     (1<<7)
;
;/*
;optimizing hints:
;- do not post/pre inc/dec integer values in operations
;- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
;- use narrow scope for variables which should be in X/Y/Z register
;- assign char sized expressions to variables to force 8 bit arithmetics
;*/
;
;/* -------------------------- String Descriptors --------------------------- */
;
;#if USB_CFG_DESCR_PROPS_STRINGS == 0
;
;#if USB_CFG_DESCR_PROPS_STRING_0 == 0
;#undef USB_CFG_DESCR_PROPS_STRING_0
;#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
;PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
;    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
;    3,          /* descriptor type */
;    0x09, 0x04, /* language index (0x0409 = US-English) */
;};
;#endif
;
;#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
;#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
;#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
;PROGMEM const int  usbDescriptorStringVendor[] = {
;    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
;    USB_CFG_VENDOR_NAME
;};
;#endif
;
;#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
;#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
;#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
;PROGMEM const int  usbDescriptorStringDevice[] = {
;    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
;    USB_CFG_DEVICE_NAME
;};
;#endif
;
;#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
;#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
;#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
;PROGMEM const int usbDescriptorStringSerialNumber[] = {
;    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
;    USB_CFG_SERIAL_NUMBER
;};
;#endif
;
;#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
;
;/* --------------------------- Device Descriptor --------------------------- */
;
;#if USB_CFG_DESCR_PROPS_DEVICE == 0
;#undef USB_CFG_DESCR_PROPS_DEVICE
;#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
;PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
;    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
;    USBDESCR_DEVICE,        /* descriptor type */
;    0x10, 0x01,             /* USB version supported */
;    USB_CFG_DEVICE_CLASS,
;    USB_CFG_DEVICE_SUBCLASS,
;    0,                      /* protocol */
;    8,                      /* max packet size */
;    /* the following two casts affect the first byte of the constant only, but
;     * that's sufficient to avoid a warning with the default values.
;     */
;    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
;    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
;    USB_CFG_DEVICE_VERSION, /* 2 bytes */
;    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
;    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
;    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
;    1,          /* number of configurations */
;};
;#endif
;
;/* ----------------------- Configuration Descriptor ------------------------ */
;
;#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
;#undef USB_CFG_DESCR_PROPS_HID
;#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
;#endif
;
;#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
;#undef USB_CFG_DESCR_PROPS_CONFIGURATION
;#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
;PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
;    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
;    USBDESCR_CONFIG,    /* descriptor type */
;    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
;                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
;                /* total length of data returned (including inlined descriptors) */
;    1,          /* number of interfaces in this configuration */
;    1,          /* index of this configuration */
;    0,          /* configuration name string index */
;#if USB_CFG_IS_SELF_POWERED
;    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
;#else
;    (1 << 7),                           /* attributes */
;#endif
;    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
;/* interface descriptor follows inline: */
;    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
;    USBDESCR_INTERFACE, /* descriptor type */
;    0,          /* index of this interface */
;    0,          /* alternate setting for this interface */
;    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to ...
;    USB_CFG_INTERFACE_CLASS,
;    USB_CFG_INTERFACE_SUBCLASS,
;    USB_CFG_INTERFACE_PROTOCOL,
;    0,          /* string index for interface */
;#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
;    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
;    USBDESCR_HID,   /* descriptor type: HID */
;    0x01, 0x01, /* BCD representation of HID version */
;    0x00,       /* target country code */
;    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
;    0x22,       /* descriptor type: report */
;    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
;#endif
;#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
;    7,          /* sizeof(usbDescrEndpoint) */
;    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
;    (char)0x81, /* IN endpoint number 1 */
;    0x03,       /* attrib: Interrupt endpoint */
;    8, 0,       /* maximum packet size */
;    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
;#endif
;#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
;    7,          /* sizeof(usbDescrEndpoint) */
;    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
;    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
;    0x03,       /* attrib: Interrupt endpoint */
;    8, 0,       /* maximum packet size */
;    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
;#endif
;};
;#endif
;
;/* ------------------------------------------------------------------------- */
;
;static inline void  usbResetDataToggling(void)
; 0000 0006 {
;#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
;    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
;#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
;    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
;#   endif
;#endif
;}
;
;static inline void  usbResetStall(void)
;{
;#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
;        usbTxLen1 = USBPID_NAK;
;#if USB_CFG_HAVE_INTRIN_ENDPOINT3
;        usbTxLen3 = USBPID_NAK;
;#endif
;#endif
;}
;
;/* ------------------------------------------------------------------------- */
;
;#if !USB_CFG_SUPPRESS_INTR_CODE
;#if USB_CFG_HAVE_INTRIN_ENDPOINT
;static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
;{

	.CSEG
;PCODE: $00000020 VOL: 0
;PCODE: $00000021 VOL: 0
;uchar   *p;
;char    i;
;
;#if USB_CFG_IMPLEMENT_HALT
;    if(usbTxLen1 == USBPID_STALL)
;        return;
;#endif
;    if(txStatus->len & 0x10){   /* packet buffer was empty */
;PCODE: $00000022 VOL: 0
;PCODE: $00000023 VOL: 0
;	*data -> Y+7
;	len -> Y+6
;	*txStatus -> Y+4
;	*p -> R16,R17
;	i -> R19
;PCODE: $00000024 VOL: 0
;PCODE: $00000025 VOL: 0
;PCODE: $00000026 VOL: 0
;PCODE: $00000027 VOL: 0
;        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
;PCODE: $00000028 VOL: 0
;PCODE: $00000029 VOL: 0
;PCODE: $0000002A VOL: 0
;PCODE: $0000002B VOL: 0
;PCODE: $0000002C VOL: 0
;PCODE: $0000002D VOL: 0
;PCODE: $0000002E VOL: 0
;PCODE: $0000002F VOL: 0
;    }else{
;PCODE: $00000030 VOL: 0
;PCODE: $00000031 VOL: 0
;        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
;PCODE: $00000032 VOL: 0
;PCODE: $00000033 VOL: 0
;PCODE: $00000034 VOL: 0
;    }
;PCODE: $00000035 VOL: 0
;    p = txStatus->buffer + 1;
;PCODE: $00000036 VOL: 0
;PCODE: $00000037 VOL: 0
;PCODE: $00000038 VOL: 0
;    i = len;
;PCODE: $00000039 VOL: 0
;PCODE: $0000003A VOL: 0
;    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
;PCODE: $0000003B VOL: 0
;        *p++ = *data++;
;PCODE: $0000003C VOL: 0
;PCODE: $0000003D VOL: 0
;PCODE: $0000003E VOL: 0
;PCODE: $0000003F VOL: 0
;PCODE: $00000040 VOL: 0
;PCODE: $00000041 VOL: 0
;PCODE: $00000042 VOL: 0
;PCODE: $00000043 VOL: 0
;    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
;PCODE: $00000044 VOL: 0
;PCODE: $00000045 VOL: 0
;PCODE: $00000046 VOL: 0
;PCODE: $00000047 VOL: 0
;PCODE: $00000048 VOL: 0
;PCODE: $00000049 VOL: 0
;PCODE: $0000004A VOL: 0
;PCODE: $0000004B VOL: 0
;    usbCrc16Append(&txStatus->buffer[1], len);
;PCODE: $0000004C VOL: 0
;PCODE: $0000004D VOL: 0
;PCODE: $0000004E VOL: 0
;PCODE: $0000004F VOL: 0
;PCODE: $00000050 VOL: 0
;    txStatus->len = len + 4;    /* len must be given including sync byte */
;PCODE: $00000051 VOL: 0
;PCODE: $00000052 VOL: 0
;PCODE: $00000053 VOL: 0
;PCODE: $00000054 VOL: 0
;    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
;}
;PCODE: $00000055 VOL: 0
;PCODE: $00000056 VOL: 0
;PCODE: $00000057 VOL: 0
;PCODE: $00000058 VOL: 0
;
;USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
;{
;PCODE: $00000059 VOL: 0
;PCODE: $0000005A VOL: 0
;    usbGenericSetInterrupt(data, len, &usbTxStatus1);
;PCODE: $0000005B VOL: 0
;	*data -> Y+1
;	len -> Y+0
;PCODE: $0000005C VOL: 0
;PCODE: $0000005D VOL: 0
;PCODE: $0000005E VOL: 0
;PCODE: $0000005F VOL: 0
;PCODE: $00000060 VOL: 0
;PCODE: $00000061 VOL: 0
;}
;PCODE: $00000062 VOL: 0
;PCODE: $00000063 VOL: 0
;PCODE: $00000064 VOL: 0
;#endif
;
;#if USB_CFG_HAVE_INTRIN_ENDPOINT3
;USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
;{
;    usbGenericSetInterrupt(data, len, &usbTxStatus3);
;}
;#endif
;#endif /* USB_CFG_SUPPRESS_INTR_CODE */
;
;/* ------------------ utilities for code following below ------------------- */
;
;/* Use defines for the switch statement so that we can choose between an
; * if()else if() and a switch/case based implementation. switch() is more
; * efficient for a LARGE set of sequential choices, if() is better in all other
; * cases.
; */
;#if USB_CFG_USE_SWITCH_STATEMENT
;#   define SWITCH_START(cmd)       switch(cmd){{
;#   define SWITCH_CASE(value)      }break; case (value):{
;#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
;#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
;#   define SWITCH_DEFAULT          }break; default:{
;#   define SWITCH_END              }}
;#else
;#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
;#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
;#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
;#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
;#   define SWITCH_DEFAULT          }else{
;#   define SWITCH_END              }}
;#endif
;
;#ifndef USB_RX_USER_HOOK
;#define USB_RX_USER_HOOK(data, len)
;#endif
;#ifndef USB_SET_ADDRESS_HOOK
;#define USB_SET_ADDRESS_HOOK()
;#endif
;
;/* ------------------------------------------------------------------------- */
;
;/* We use if() instead of #if in the macro below because #if can't be used
; * in macros and the compiler optimizes constant conditions anyway.
; * This may cause problems with undefined symbols if compiled without
; * optimizing!
; */
;#define GET_DESCRIPTOR(cfgProp, staticName)         \
;    if(cfgProp){                                    \
;        if((cfgProp) & USB_PROP_IS_RAM)             \
;            flags = 0;                              \
;        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
;            len = usbFunctionDescriptor(rq);        \
;        }else{                                      \
;            len = USB_PROP_LENGTH(cfgProp);         \
;            usbMsgPtr = (usbMsgPtr_t)(staticName);  \
;        }                                           \
;    }
;
;/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
; * internally for all types of descriptors.
; */
;static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
;{
;usbMsgLen_t len = 0;
;uchar       flags = USB_FLG_MSGPTR_IS_ROM;
;
;    SWITCH_START(rq->wValue.bytes[1])
;	*rq -> Y+2
;	len -> R17
;	flags -> R16
;    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
;        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
;    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
;        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
;    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
;#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
;        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
;            flags = 0;
;        len = usbFunctionDescriptor(rq);
;#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
;        SWITCH_START(rq->wValue.bytes[0])
;        SWITCH_CASE(0)
;            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
;        SWITCH_CASE(1)
;            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
;        SWITCH_CASE(2)
;            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
;        SWITCH_CASE(3)
;            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
;        SWITCH_DEFAULT
;            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
;                len = usbFunctionDescriptor(rq);
;            }
;        SWITCH_END
;#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
;#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
;    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
;        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
;    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
;        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
;#endif
;    SWITCH_DEFAULT
;        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
;            len = usbFunctionDescriptor(rq);
;        }
;    SWITCH_END
;    usbMsgFlags = flags;
;    return len;
;}
;
;/* ------------------------------------------------------------------------- */
;
;/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
; * standard requests instead of class and custom requests.
; */
;static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
;{
;usbMsgLen_t len = 0;
;uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
;uchar   value = rq->wValue.bytes[0];
;#if USB_CFG_IMPLEMENT_HALT
;uchar   index = rq->wIndex.bytes[0];
;#endif
;
;    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
;	*rq -> Y+4
;	len -> R17
;	*dataPtr -> R18,R19
;	value -> R16
;    SWITCH_START(rq->bRequest)
;    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
;        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
;        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
;	*rq -> Y+5
;	recipient -> Y+0
;            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
;#if USB_CFG_IMPLEMENT_HALT
;        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
;            dataPtr[0] = usbTxLen1 == USBPID_STALL;
;#endif
;        dataPtr[1] = 0;
;        len = 2;
;#if USB_CFG_IMPLEMENT_HALT
;    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
;        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
;            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
;            usbResetDataToggling();
;        }
;#endif
;    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
;        usbNewDeviceAddr = value;
;        USB_SET_ADDRESS_HOOK();
;    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
;        len = usbDriverDescriptor(rq);
;        goto skipMsgPtrAssignment;
;    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
;        dataPtr = &usbConfiguration;  /* send current configuration value */
;        len = 1;
;    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
;        usbConfiguration = value;
;        usbResetStall();
;    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
;        len = 1;
;#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
;    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
;        usbResetDataToggling();
;        usbResetStall();
;#endif
;    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
;        /* Should we add an optional hook here? */
;    SWITCH_END
;    usbMsgPtr = (usbMsgPtr_t)dataPtr;
;skipMsgPtrAssignment:
;    return len;
;}
;
;/* ------------------------------------------------------------------------- */
;
;/* usbProcessRx() is called for every message received by the interrupt
; * routine. It distinguishes between SETUP and DATA packets and processes
; * them accordingly.
; */
;static inline void usbProcessRx(uchar *data, uchar len)
;{
;usbRequest_t    *rq = (void *)data;
;
;/* usbRxToken can be:
; * 0x2d 00101101 (USBPID_SETUP for setup data)
; * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
; * 0...0x0f for OUT on endpoint X
; */
;    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
;    USB_RX_USER_HOOK(data, len)
;#if USB_CFG_IMPLEMENT_FN_WRITEOUT
;    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
;        usbFunctionWriteOut(data, len);
;        return;
;    }
;#endif
;    if(usbRxToken == (uchar)USBPID_SETUP){
;	*data -> Y+3
;	len -> Y+2
;	*rq -> R16,R17
;        usbMsgLen_t replyLen;
;        uchar type;
;        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
;	*data -> Y+5
;	len -> Y+4
;	replyLen -> Y+1
;	type -> Y+0
;            return;
;        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
;        usbTxLen = USBPID_NAK;              /* abort pending transmit */
;        usbMsgFlags = 0;
;        type = rq->bmRequestType & USBRQ_TYPE_MASK;
;        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
;            replyLen = usbFunctionSetup(data);
;        }else{
;            replyLen = usbDriverSetup(rq);
;        }
;#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
;        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
;            /* do some conditioning on replyLen, but on IN transfers only */
;            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
;                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
;                    replyLen = rq->wLength.bytes[0];
;                }else{
;                    replyLen = rq->wLength.word;
;                }
;            }
;            usbMsgFlags = USB_FLG_USE_USER_RW;
;        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
;#endif
;        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
;            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
;                replyLen = rq->wLength.bytes[0];
;        }else{
;            if(replyLen > rq->wLength.word)     /* limit length to max */
;                replyLen = rq->wLength.word;
;        }
;        usbMsgLen = replyLen;
;    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
;#if USB_CFG_IMPLEMENT_FN_WRITE
;        if(usbMsgFlags & USB_FLG_USE_USER_RW){
;            uchar rval = usbFunctionWrite(data, len);
;            if(rval == 0xff){   /* an error occurred */
;	*data -> Y+4
;	len -> Y+3
;	rval -> Y+0
;                usbTxLen = USBPID_STALL;
;            }else if(rval != 0){    /* This was the final package */
;                usbMsgLen = 0;  /* answer with a zero-sized data packet */
;            }
;        }
;#endif
;    }
;}
;
;/* ------------------------------------------------------------------------- */
;
;/* This function is similar to usbFunctionRead(), but it's also called for
; * data handled automatically by the driver (e.g. descriptor reads).
; */
;static uchar usbDeviceRead(uchar *data, uchar len)
;{
;PCODE: $00000065 VOL: 0
;PCODE: $00000066 VOL: 0
;    if(len > 0){    /* don't bother app with 0 sized reads */
;PCODE: $00000067 VOL: 0
;	*data -> Y+1
;	len -> Y+0
;PCODE: $00000068 VOL: 0
;PCODE: $00000069 VOL: 0
;PCODE: $0000006A VOL: 0
;#if USB_CFG_IMPLEMENT_FN_READ
;        if(usbMsgFlags & USB_FLG_USE_USER_RW){
;PCODE: $0000006B VOL: 0
;PCODE: $0000006C VOL: 0
;PCODE: $0000006D VOL: 0
;            len = usbFunctionRead(data, len);
;PCODE: $0000006E VOL: 0
;PCODE: $0000006F VOL: 0
;PCODE: $00000070 VOL: 0
;PCODE: $00000071 VOL: 0
;PCODE: $00000072 VOL: 0
;        }else
;PCODE: $00000073 VOL: 0
;PCODE: $00000074 VOL: 0
;#endif
;        {
;            uchar i = len;
;            usbMsgPtr_t r = usbMsgPtr;
;            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
;PCODE: $00000075 VOL: 0
;	*data -> Y+4
;	len -> Y+3
;	i -> Y+2
;	*r -> Y+0
;PCODE: $00000076 VOL: 0
;PCODE: $00000077 VOL: 0
;PCODE: $00000078 VOL: 0
;PCODE: $00000079 VOL: 0
;PCODE: $0000007A VOL: 0
;PCODE: $0000007B VOL: 0
;PCODE: $0000007C VOL: 0
;                do{
;PCODE: $0000007D VOL: 0
;                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
;                    *data++ = c;
;PCODE: $0000007E VOL: 0
;	*data -> Y+5
;	len -> Y+4
;	i -> Y+3
;	*r -> Y+1
;	c -> Y+0
;PCODE: $0000007F VOL: 0
;PCODE: $00000080 VOL: 0
;PCODE: $00000081 VOL: 0
;PCODE: $00000082 VOL: 0
;PCODE: $00000083 VOL: 0
;PCODE: $00000084 VOL: 0
;PCODE: $00000085 VOL: 0
;PCODE: $00000086 VOL: 0
;PCODE: $00000087 VOL: 0
;                    r++;
;PCODE: $00000088 VOL: 0
;PCODE: $00000089 VOL: 0
;PCODE: $0000008A VOL: 0
;                }while(--i);
;PCODE: $0000008B VOL: 0
;PCODE: $0000008C VOL: 0
;PCODE: $0000008D VOL: 0
;PCODE: $0000008E VOL: 0
;PCODE: $0000008F VOL: 0
;PCODE: $00000090 VOL: 0
;PCODE: $00000091 VOL: 0
;PCODE: $00000092 VOL: 0
;            }else{  /* RAM data */
;PCODE: $00000093 VOL: 0
;PCODE: $00000094 VOL: 0
;                do{
;PCODE: $00000095 VOL: 0
;                    *data++ = *((uchar *)r);
;PCODE: $00000096 VOL: 0
;PCODE: $00000097 VOL: 0
;PCODE: $00000098 VOL: 0
;PCODE: $00000099 VOL: 0
;PCODE: $0000009A VOL: 0
;PCODE: $0000009B VOL: 0
;PCODE: $0000009C VOL: 0
;PCODE: $0000009D VOL: 0
;PCODE: $0000009E VOL: 0
;                    r++;
;PCODE: $0000009F VOL: 0
;PCODE: $000000A0 VOL: 0
;PCODE: $000000A1 VOL: 0
;                }while(--i);
;PCODE: $000000A2 VOL: 0
;PCODE: $000000A3 VOL: 0
;PCODE: $000000A4 VOL: 0
;PCODE: $000000A5 VOL: 0
;PCODE: $000000A6 VOL: 0
;PCODE: $000000A7 VOL: 0
;PCODE: $000000A8 VOL: 0
;            }
;PCODE: $000000A9 VOL: 0
;            usbMsgPtr = r;
;PCODE: $000000AA VOL: 0
;PCODE: $000000AB VOL: 0
;        }
;PCODE: $000000AC VOL: 0
;PCODE: $000000AD VOL: 0
;    }
;    return len;
;PCODE: $000000AE VOL: 0
;PCODE: $000000AF VOL: 0
;PCODE: $000000B0 VOL: 0
;PCODE: $000000B1 VOL: 0
;}
;PCODE: $000000B2 VOL: 0
;
;/* ------------------------------------------------------------------------- */
;
;/* usbBuildTxBlock() is called when we have data to transmit and the
; * interrupt routine's transmit buffer is empty.
; */
;static inline void usbBuildTxBlock(void)
;{
;usbMsgLen_t wantLen;
;uchar       len;
;
;    wantLen = usbMsgLen;
;	wantLen -> R17
;	len -> R16
;    if(wantLen > 8)
;        wantLen = 8;
;    usbMsgLen -= wantLen;
;    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
;    len = usbDeviceRead(usbTxBuf + 1, wantLen);
;    if(len <= 8){           /* valid data packet */
;        usbCrc16Append(&usbTxBuf[1], len);
;        len += 4;           /* length including sync byte */
;        if(len < 12)        /* a partial package identifies end of message */
;            usbMsgLen = USB_NO_MSG;
;    }else{
;        len = USBPID_STALL;   /* stall the endpoint */
;        usbMsgLen = USB_NO_MSG;
;    }
;    usbTxLen = len;
;    DBG2(0x20, usbTxBuf, len-1);
;}
;
;/* ------------------------------------------------------------------------- */
;
;static inline void usbHandleResetHook(uchar notResetState)
;{
;#ifdef USB_RESET_HOOK
;static uchar    wasReset;
;uchar           isReset = !notResetState;
;
;    if(wasReset != isReset){
;        USB_RESET_HOOK(isReset);
;        wasReset = isReset;
;    }
;#else
;    notResetState = notResetState;  // avoid compiler warning
;	notResetState -> Y+0
;#endif
;}
;
;/* ------------------------------------------------------------------------- */
;
;USB_PUBLIC void usbPoll(void)
;{
;PCODE: $000000B3 VOL: 0
;PCODE: $000000B4 VOL: 0
;schar   len;
;uchar   i;
;
;    len = usbRxLen - 3;
;PCODE: $000000B5 VOL: 0
;	len -> R17
;	i -> R16
;PCODE: $000000B6 VOL: 0
;PCODE: $000000B7 VOL: 1
;PCODE: $000000B8 VOL: 0
;    if(len >= 0){
;PCODE: $000000B9 VOL: 0
;PCODE: $000000BA VOL: 0
;/* We could check CRC16 here -- but ACK has already been sent anyway. If you
; * need data integrity checks with this driver, check the CRC in your app
; * code and report errors back to the host. Since the ACK was already sent,
; * retries must be handled on application level.
; * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
; */
;        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
;PCODE: $000000BB VOL: 0
;PCODE: $000000BC VOL: 0
;PCODE: $000000BD VOL: 0
;PCODE: $000000BE VOL: 0
;PCODE: $000000BF VOL: 0
;PCODE: $000000C0 VOL: 0
;PCODE: $000000C1 VOL: 0
;PCODE: $000000C2 VOL: 0
;PCODE: $000000C3 VOL: 0
;PCODE: $000000C4 VOL: 0
;PCODE: $000000C5 VOL: 0
;PCODE: $000000C6 VOL: 0
;PCODE: $000000C7 VOL: 0
;PCODE: $000000C8 VOL: 0
;PCODE: $000000C9 VOL: 0
;PCODE: $000000CA VOL: 0
;PCODE: $000000CB VOL: 0
;PCODE: $000000CC VOL: 0
;PCODE: $000000CD VOL: 0
;PCODE: $000000CE VOL: 0
;PCODE: $000000CF VOL: 0
;PCODE: $000000D0 VOL: 0
;PCODE: $000000D1 VOL: 0
;PCODE: $000000D2 VOL: 0
;PCODE: $000000D3 VOL: 0
;PCODE: $000000D4 VOL: 0
;PCODE: $000000D5 VOL: 1
;PCODE: $000000D6 VOL: 0
;PCODE: $000000D7 VOL: 0
;PCODE: $000000D8 VOL: 0
;PCODE: $000000D9 VOL: 0
;PCODE: $000000DA VOL: 0
;PCODE: $000000DB VOL: 0
;PCODE: $000000DC VOL: 0
;PCODE: $000000DD VOL: 0
;PCODE: $000000DE VOL: 0
;PCODE: $000000DF VOL: 0
;PCODE: $000000E0 VOL: 0
;PCODE: $000000E1 VOL: 0
;PCODE: $000000E2 VOL: 0
;PCODE: $000000E3 VOL: 0
;PCODE: $000000E4 VOL: 0
;PCODE: $000000E5 VOL: 0
;PCODE: $000000E6 VOL: 0
;PCODE: $000000E7 VOL: 0
;PCODE: $000000E8 VOL: 0
;PCODE: $000000E9 VOL: 0
;PCODE: $000000EA VOL: 0
;PCODE: $000000EB VOL: 0
;PCODE: $000000EC VOL: 0
;PCODE: $000000ED VOL: 0
;PCODE: $000000EE VOL: 0
;PCODE: $000000EF VOL: 0
;PCODE: $000000F0 VOL: 0
;PCODE: $000000F1 VOL: 0
;PCODE: $000000F2 VOL: 0
;PCODE: $000000F3 VOL: 0
;PCODE: $000000F4 VOL: 0
;PCODE: $000000F5 VOL: 0
;PCODE: $000000F6 VOL: 0
;PCODE: $000000F7 VOL: 0
;PCODE: $000000F8 VOL: 0
;PCODE: $000000F9 VOL: 0
;PCODE: $000000FA VOL: 0
;PCODE: $000000FB VOL: 0
;PCODE: $000000FC VOL: 0
;PCODE: $000000FD VOL: 0
;PCODE: $000000FE VOL: 0
;PCODE: $000000FF VOL: 0
;PCODE: $00000100 VOL: 0
;PCODE: $00000101 VOL: 0
;PCODE: $00000102 VOL: 0
;PCODE: $00000103 VOL: 0
;PCODE: $00000104 VOL: 0
;PCODE: $00000105 VOL: 0
;PCODE: $00000106 VOL: 0
;PCODE: $00000107 VOL: 0
;PCODE: $00000108 VOL: 0
;PCODE: $00000109 VOL: 0
;PCODE: $0000010A VOL: 0
;PCODE: $0000010B VOL: 0
;PCODE: $0000010C VOL: 0
;PCODE: $0000010D VOL: 0
;PCODE: $0000010E VOL: 0
;PCODE: $0000010F VOL: 0
;PCODE: $00000110 VOL: 0
;PCODE: $00000111 VOL: 0
;PCODE: $00000112 VOL: 0
;PCODE: $00000113 VOL: 0
;PCODE: $00000114 VOL: 0
;PCODE: $00000115 VOL: 0
;PCODE: $00000116 VOL: 0
;PCODE: $00000117 VOL: 0
;PCODE: $00000118 VOL: 0
;PCODE: $00000119 VOL: 0
;PCODE: $0000011A VOL: 0
;PCODE: $0000011B VOL: 0
;PCODE: $0000011C VOL: 0
;PCODE: $0000011D VOL: 0
;PCODE: $0000011E VOL: 0
;PCODE: $0000011F VOL: 0
;PCODE: $00000120 VOL: 0
;PCODE: $00000121 VOL: 0
;PCODE: $00000122 VOL: 0
;PCODE: $00000123 VOL: 0
;PCODE: $00000124 VOL: 0
;PCODE: $00000125 VOL: 0
;PCODE: $00000126 VOL: 0
;PCODE: $00000127 VOL: 0
;PCODE: $00000128 VOL: 0
;PCODE: $00000129 VOL: 0
;PCODE: $0000012A VOL: 0
;PCODE: $0000012B VOL: 0
;PCODE: $0000012C VOL: 0
;PCODE: $0000012D VOL: 0
;PCODE: $0000012E VOL: 0
;PCODE: $0000012F VOL: 0
;PCODE: $00000130 VOL: 0
;PCODE: $00000131 VOL: 0
;PCODE: $00000132 VOL: 0
;PCODE: $00000133 VOL: 0
;PCODE: $00000134 VOL: 0
;PCODE: $00000135 VOL: 0
;PCODE: $00000136 VOL: 0
;PCODE: $00000137 VOL: 0
;PCODE: $00000138 VOL: 0
;PCODE: $00000139 VOL: 0
;PCODE: $0000013A VOL: 0
;PCODE: $0000013B VOL: 0
;PCODE: $0000013C VOL: 0
;PCODE: $0000013D VOL: 0
;PCODE: $0000013E VOL: 0
;PCODE: $0000013F VOL: 0
;PCODE: $00000140 VOL: 0
;PCODE: $00000141 VOL: 0
;PCODE: $00000142 VOL: 0
;PCODE: $00000143 VOL: 0
;PCODE: $00000144 VOL: 0
;PCODE: $00000145 VOL: 0
;PCODE: $00000146 VOL: 0
;PCODE: $00000147 VOL: 0
;PCODE: $00000148 VOL: 0
;PCODE: $00000149 VOL: 0
;PCODE: $0000014A VOL: 0
;PCODE: $0000014B VOL: 0
;PCODE: $0000014C VOL: 0
;PCODE: $0000014D VOL: 0
;PCODE: $0000014E VOL: 0
;PCODE: $0000014F VOL: 0
;PCODE: $00000150 VOL: 0
;PCODE: $00000151 VOL: 0
;PCODE: $00000152 VOL: 0
;PCODE: $00000153 VOL: 0
;PCODE: $00000154 VOL: 0
;PCODE: $00000155 VOL: 0
;PCODE: $00000156 VOL: 0
;PCODE: $00000157 VOL: 0
;PCODE: $00000158 VOL: 0
;PCODE: $00000159 VOL: 0
;PCODE: $0000015A VOL: 0
;PCODE: $0000015B VOL: 0
;PCODE: $0000015C VOL: 0
;PCODE: $0000015D VOL: 0
;PCODE: $0000015E VOL: 0
;PCODE: $0000015F VOL: 0
;PCODE: $00000160 VOL: 0
;PCODE: $00000161 VOL: 0
;PCODE: $00000162 VOL: 0
;PCODE: $00000163 VOL: 0
;PCODE: $00000164 VOL: 0
;PCODE: $00000165 VOL: 0
;PCODE: $00000166 VOL: 0
;PCODE: $00000167 VOL: 0
;PCODE: $00000168 VOL: 0
;PCODE: $00000169 VOL: 0
;PCODE: $0000016A VOL: 0
;PCODE: $0000016B VOL: 0
;PCODE: $0000016C VOL: 0
;PCODE: $0000016D VOL: 0
;PCODE: $0000016E VOL: 0
;PCODE: $0000016F VOL: 0
;PCODE: $00000170 VOL: 0
;PCODE: $00000171 VOL: 0
;PCODE: $00000172 VOL: 0
;PCODE: $00000173 VOL: 0
;PCODE: $00000174 VOL: 0
;PCODE: $00000175 VOL: 0
;PCODE: $00000176 VOL: 0
;PCODE: $00000177 VOL: 0
;PCODE: $00000178 VOL: 0
;PCODE: $00000179 VOL: 0
;PCODE: $0000017A VOL: 0
;PCODE: $0000017B VOL: 0
;PCODE: $0000017C VOL: 0
;PCODE: $0000017D VOL: 0
;PCODE: $0000017E VOL: 0
;PCODE: $0000017F VOL: 0
;PCODE: $00000180 VOL: 0
;PCODE: $00000181 VOL: 0
;PCODE: $00000182 VOL: 0
;PCODE: $00000183 VOL: 0
;PCODE: $00000184 VOL: 0
;PCODE: $00000185 VOL: 0
;PCODE: $00000186 VOL: 0
;PCODE: $00000187 VOL: 0
;PCODE: $00000188 VOL: 0
;PCODE: $00000189 VOL: 0
;PCODE: $0000018A VOL: 0
;PCODE: $0000018B VOL: 0
;PCODE: $0000018C VOL: 0
;PCODE: $0000018D VOL: 0
;PCODE: $0000018E VOL: 0
;PCODE: $0000018F VOL: 0
;PCODE: $00000190 VOL: 0
;PCODE: $00000191 VOL: 0
;PCODE: $00000192 VOL: 0
;PCODE: $00000193 VOL: 0
;PCODE: $00000194 VOL: 0
;PCODE: $00000195 VOL: 0
;PCODE: $00000196 VOL: 0
;PCODE: $00000197 VOL: 0
;PCODE: $00000198 VOL: 0
;PCODE: $00000199 VOL: 0
;PCODE: $0000019A VOL: 0
;PCODE: $0000019B VOL: 0
;PCODE: $0000019C VOL: 0
;PCODE: $0000019D VOL: 0
;PCODE: $0000019E VOL: 0
;PCODE: $0000019F VOL: 0
;PCODE: $000001A0 VOL: 0
;PCODE: $000001A1 VOL: 0
;PCODE: $000001A2 VOL: 0
;PCODE: $000001A3 VOL: 0
;PCODE: $000001A4 VOL: 0
;PCODE: $000001A5 VOL: 0
;PCODE: $000001A6 VOL: 0
;PCODE: $000001A7 VOL: 0
;PCODE: $000001A8 VOL: 0
;PCODE: $000001A9 VOL: 0
;PCODE: $000001AA VOL: 0
;PCODE: $000001AB VOL: 0
;PCODE: $000001AC VOL: 0
;PCODE: $000001AD VOL: 0
;PCODE: $000001AE VOL: 0
;PCODE: $000001AF VOL: 0
;PCODE: $000001B0 VOL: 0
;PCODE: $000001B1 VOL: 0
;PCODE: $000001B2 VOL: 0
;PCODE: $000001B3 VOL: 0
;PCODE: $000001B4 VOL: 0
;PCODE: $000001B5 VOL: 0
;PCODE: $000001B6 VOL: 0
;PCODE: $000001B7 VOL: 0
;PCODE: $000001B8 VOL: 0
;PCODE: $000001B9 VOL: 0
;PCODE: $000001BA VOL: 0
;PCODE: $000001BB VOL: 0
;PCODE: $000001BC VOL: 0
;PCODE: $000001BD VOL: 0
;PCODE: $000001BE VOL: 0
;PCODE: $000001BF VOL: 0
;PCODE: $000001C0 VOL: 0
;PCODE: $000001C1 VOL: 0
;PCODE: $000001C2 VOL: 0
;PCODE: $000001C3 VOL: 0
;PCODE: $000001C4 VOL: 0
;PCODE: $000001C5 VOL: 0
;PCODE: $000001C6 VOL: 0
;PCODE: $000001C7 VOL: 0
;PCODE: $000001C8 VOL: 0
;PCODE: $000001C9 VOL: 0
;PCODE: $000001CA VOL: 0
;PCODE: $000001CB VOL: 0
;PCODE: $000001CC VOL: 0
;PCODE: $000001CD VOL: 0
;PCODE: $000001CE VOL: 0
;PCODE: $000001CF VOL: 0
;PCODE: $000001D0 VOL: 0
;PCODE: $000001D1 VOL: 0
;PCODE: $000001D2 VOL: 0
;PCODE: $000001D3 VOL: 0
;PCODE: $000001D4 VOL: 0
;PCODE: $000001D5 VOL: 0
;PCODE: $000001D6 VOL: 0
;PCODE: $000001D7 VOL: 0
;PCODE: $000001D8 VOL: 0
;PCODE: $000001D9 VOL: 0
;PCODE: $000001DA VOL: 0
;PCODE: $000001DB VOL: 0
;PCODE: $000001DC VOL: 0
;PCODE: $000001DD VOL: 0
;PCODE: $000001DE VOL: 0
;PCODE: $000001DF VOL: 0
;PCODE: $000001E0 VOL: 0
;PCODE: $000001E1 VOL: 0
;PCODE: $000001E2 VOL: 0
;PCODE: $000001E3 VOL: 0
;PCODE: $000001E4 VOL: 0
;PCODE: $000001E5 VOL: 0
;PCODE: $000001E6 VOL: 0
;PCODE: $000001E7 VOL: 0
;PCODE: $000001E8 VOL: 0
;PCODE: $000001E9 VOL: 0
;PCODE: $000001EA VOL: 0
;PCODE: $000001EB VOL: 0
;PCODE: $000001EC VOL: 0
;PCODE: $000001ED VOL: 0
;PCODE: $000001EE VOL: 0
;PCODE: $000001EF VOL: 0
;PCODE: $000001F0 VOL: 0
;PCODE: $000001F1 VOL: 0
;PCODE: $000001F2 VOL: 0
;PCODE: $000001F3 VOL: 0
;PCODE: $000001F4 VOL: 0
;PCODE: $000001F5 VOL: 0
;PCODE: $000001F6 VOL: 0
;PCODE: $000001F7 VOL: 0
;PCODE: $000001F8 VOL: 0
;PCODE: $000001F9 VOL: 0
;PCODE: $000001FA VOL: 0
;PCODE: $000001FB VOL: 0
;PCODE: $000001FC VOL: 0
;PCODE: $000001FD VOL: 0
;PCODE: $000001FE VOL: 0
;PCODE: $000001FF VOL: 0
;PCODE: $00000200 VOL: 0
;PCODE: $00000201 VOL: 0
;PCODE: $00000202 VOL: 0
;PCODE: $00000203 VOL: 0
;PCODE: $00000204 VOL: 0
;PCODE: $00000205 VOL: 0
;PCODE: $00000206 VOL: 0
;PCODE: $00000207 VOL: 0
;PCODE: $00000208 VOL: 0
;PCODE: $00000209 VOL: 0
;PCODE: $0000020A VOL: 0
;PCODE: $0000020B VOL: 0
;PCODE: $0000020C VOL: 0
;PCODE: $0000020D VOL: 0
;PCODE: $0000020E VOL: 0
;PCODE: $0000020F VOL: 0
;PCODE: $00000210 VOL: 0
;PCODE: $00000211 VOL: 0
;PCODE: $00000212 VOL: 0
;PCODE: $00000213 VOL: 0
;PCODE: $00000214 VOL: 0
;PCODE: $00000215 VOL: 0
;PCODE: $00000216 VOL: 0
;PCODE: $00000217 VOL: 0
;PCODE: $00000218 VOL: 0
;PCODE: $00000219 VOL: 0
;PCODE: $0000021A VOL: 0
;PCODE: $0000021B VOL: 0
;PCODE: $0000021C VOL: 0
;PCODE: $0000021D VOL: 0
;PCODE: $0000021E VOL: 0
;PCODE: $0000021F VOL: 0
;PCODE: $00000220 VOL: 0
;PCODE: $00000221 VOL: 0
;PCODE: $00000222 VOL: 0
;PCODE: $00000223 VOL: 0
;PCODE: $00000224 VOL: 0
;PCODE: $00000225 VOL: 0
;PCODE: $00000226 VOL: 0
;PCODE: $00000227 VOL: 0
;PCODE: $00000228 VOL: 0
;PCODE: $00000229 VOL: 0
;PCODE: $0000022A VOL: 0
;PCODE: $0000022B VOL: 0
;PCODE: $0000022C VOL: 0
;PCODE: $0000022D VOL: 0
;PCODE: $0000022E VOL: 0
;PCODE: $0000022F VOL: 0
;PCODE: $00000230 VOL: 0
;PCODE: $00000231 VOL: 0
;PCODE: $00000232 VOL: 0
;PCODE: $00000233 VOL: 0
;PCODE: $00000234 VOL: 0
;PCODE: $00000235 VOL: 0
;PCODE: $00000236 VOL: 0
;PCODE: $00000237 VOL: 0
;PCODE: $00000238 VOL: 0
;PCODE: $00000239 VOL: 0
;PCODE: $0000023A VOL: 0
;PCODE: $0000023B VOL: 0
;PCODE: $0000023C VOL: 0
;PCODE: $0000023D VOL: 0
;PCODE: $0000023E VOL: 0
;PCODE: $0000023F VOL: 0
;PCODE: $00000240 VOL: 0
;PCODE: $00000241 VOL: 0
;PCODE: $00000242 VOL: 0
;PCODE: $00000243 VOL: 0
;PCODE: $00000244 VOL: 0
;PCODE: $00000245 VOL: 0
;PCODE: $00000246 VOL: 0
;PCODE: $00000247 VOL: 0
;PCODE: $00000248 VOL: 0
;PCODE: $00000249 VOL: 0
;PCODE: $0000024A VOL: 0
;PCODE: $0000024B VOL: 0
;PCODE: $0000024C VOL: 0
;PCODE: $0000024D VOL: 0
;PCODE: $0000024E VOL: 0
;PCODE: $0000024F VOL: 0
;PCODE: $00000250 VOL: 0
;PCODE: $00000251 VOL: 0
;PCODE: $00000252 VOL: 0
;PCODE: $00000253 VOL: 0
;PCODE: $00000254 VOL: 0
;PCODE: $00000255 VOL: 0
;PCODE: $00000256 VOL: 0
;PCODE: $00000257 VOL: 0
;PCODE: $00000258 VOL: 0
;PCODE: $00000259 VOL: 0
;PCODE: $0000025A VOL: 0
;PCODE: $0000025B VOL: 0
;PCODE: $0000025C VOL: 0
;PCODE: $0000025D VOL: 0
;PCODE: $0000025E VOL: 0
;PCODE: $0000025F VOL: 0
;PCODE: $00000260 VOL: 0
;PCODE: $00000261 VOL: 0
;PCODE: $00000262 VOL: 0
;PCODE: $00000263 VOL: 0
;PCODE: $00000264 VOL: 1
;PCODE: $00000265 VOL: 0
;PCODE: $00000266 VOL: 0
;PCODE: $00000267 VOL: 0
;PCODE: $00000268 VOL: 0
;PCODE: $00000269 VOL: 0
;PCODE: $0000026A VOL: 0
;PCODE: $0000026B VOL: 0
;PCODE: $0000026C VOL: 0
;PCODE: $0000026D VOL: 0
;PCODE: $0000026E VOL: 0
;PCODE: $0000026F VOL: 0
;PCODE: $00000270 VOL: 0
;PCODE: $00000271 VOL: 0
;PCODE: $00000272 VOL: 0
;PCODE: $00000273 VOL: 0
;PCODE: $00000274 VOL: 0
;PCODE: $00000275 VOL: 0
;PCODE: $00000276 VOL: 0
;#if USB_CFG_HAVE_FLOWCONTROL
;        if(usbRxLen > 0)    /* only mark as available if not inactivated */
;            usbRxLen = 0;
;#else
;        usbRxLen = 0;       /* mark rx buffer as available */
;PCODE: $00000277 VOL: 0
;PCODE: $00000278 VOL: 1
;#endif
;    }
;    if(usbTxLen & 0x10){    /* transmit system idle */
;PCODE: $00000279 VOL: 0
;PCODE: $0000027A VOL: 1
;PCODE: $0000027B VOL: 0
;PCODE: $0000027C VOL: 0
;        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
;PCODE: $0000027D VOL: 0
;PCODE: $0000027E VOL: 0
;PCODE: $0000027F VOL: 0
;            usbBuildTxBlock();
;PCODE: $00000280 VOL: 0
;PCODE: $00000281 VOL: 0
;PCODE: $00000282 VOL: 0
;PCODE: $00000283 VOL: 0
;PCODE: $00000284 VOL: 0
;PCODE: $00000285 VOL: 0
;PCODE: $00000286 VOL: 0
;PCODE: $00000287 VOL: 0
;PCODE: $00000288 VOL: 0
;PCODE: $00000289 VOL: 0
;PCODE: $0000028A VOL: 0
;PCODE: $0000028B VOL: 0
;PCODE: $0000028C VOL: 0
;PCODE: $0000028D VOL: 0
;PCODE: $0000028E VOL: 0
;PCODE: $0000028F VOL: 0
;PCODE: $00000290 VOL: 0
;PCODE: $00000291 VOL: 0
;PCODE: $00000292 VOL: 0
;PCODE: $00000293 VOL: 0
;PCODE: $00000294 VOL: 0
;PCODE: $00000295 VOL: 0
;PCODE: $00000296 VOL: 0
;PCODE: $00000297 VOL: 0
;PCODE: $00000298 VOL: 0
;PCODE: $00000299 VOL: 0
;PCODE: $0000029A VOL: 0
;PCODE: $0000029B VOL: 0
;PCODE: $0000029C VOL: 0
;PCODE: $0000029D VOL: 0
;PCODE: $0000029E VOL: 0
;PCODE: $0000029F VOL: 0
;PCODE: $000002A0 VOL: 0
;PCODE: $000002A1 VOL: 0
;PCODE: $000002A2 VOL: 0
;PCODE: $000002A3 VOL: 0
;PCODE: $000002A4 VOL: 0
;PCODE: $000002A5 VOL: 0
;PCODE: $000002A6 VOL: 0
;PCODE: $000002A7 VOL: 0
;PCODE: $000002A8 VOL: 0
;PCODE: $000002A9 VOL: 0
;PCODE: $000002AA VOL: 0
;PCODE: $000002AB VOL: 0
;PCODE: $000002AC VOL: 0
;PCODE: $000002AD VOL: 0
;PCODE: $000002AE VOL: 1
;PCODE: $000002AF VOL: 0
;PCODE: $000002B0 VOL: 0
;PCODE: $000002B1 VOL: 0
;PCODE: $000002B2 VOL: 0
;PCODE: $000002B3 VOL: 0
;        }
;    }
;PCODE: $000002B4 VOL: 0
;    for(i = 20; i > 0; i--){
;PCODE: $000002B5 VOL: 0
;PCODE: $000002B6 VOL: 0
;PCODE: $000002B7 VOL: 0
;PCODE: $000002B8 VOL: 0
;PCODE: $000002B9 VOL: 0
;PCODE: $000002BA VOL: 0
;PCODE: $000002BB VOL: 0
;PCODE: $000002BC VOL: 0
;PCODE: $000002BD VOL: 0
;PCODE: $000002BE VOL: 0
;        uchar usbLineStatus = USBIN & USBMASK;
;        if(usbLineStatus != 0){  /* SE0 has ended */
;PCODE: $000002BF VOL: 0
;	usbLineStatus -> Y+0
;PCODE: $000002C0 VOL: 0
;PCODE: $000002C1 VOL: 0
;PCODE: $000002C2 VOL: 0
;PCODE: $000002C3 VOL: 0
;PCODE: $000002C4 VOL: 0
;PCODE: $000002C5 VOL: 0
;            goto isNotReset;   }
;PCODE: $000002C6 VOL: 0
;    }
;PCODE: $000002C7 VOL: 0
;PCODE: $000002C8 VOL: 0
;PCODE: $000002C9 VOL: 0
;PCODE: $000002CA VOL: 0
;PCODE: $000002CB VOL: 0
;PCODE: $000002CC VOL: 0
;PCODE: $000002CD VOL: 0
;    /* RESET condition, called multiple times during reset */
;    usbNewDeviceAddr = 0;
;PCODE: $000002CE VOL: 0
;    usbDeviceAddr = 0;
;PCODE: $000002CF VOL: 0
;    usbResetStall();
;PCODE: $000002D0 VOL: 0
;PCODE: $000002D1 VOL: 0
;PCODE: $000002D2 VOL: 0
;PCODE: $000002D3 VOL: 0
;    DBG1(0xff, 0, 0);
;isNotReset:
;PCODE: $000002D4 VOL: 0
;    usbHandleResetHook(i);
;PCODE: $000002D5 VOL: 0
;PCODE: $000002D6 VOL: 0
;PCODE: $000002D7 VOL: 0
;PCODE: $000002D8 VOL: 0
;PCODE: $000002D9 VOL: 0
;PCODE: $000002DA VOL: 0
;PCODE: $000002DB VOL: 0
;PCODE: $000002DC VOL: 0
;PCODE: $000002DD VOL: 0
;}
;PCODE: $000002DE VOL: 0
;PCODE: $000002DF VOL: 0
;PCODE: $000002E0 VOL: 0
;
;/* ------------------------------------------------------------------------- */
;
;USB_PUBLIC void usbInit(void)
;{
;PCODE: $000002E1 VOL: 0
;PCODE: $000002E2 VOL: 0
;#if USB_INTR_CFG_SET != 0
;    USB_INTR_CFG |= USB_INTR_CFG_SET;
;PCODE: $000002E3 VOL: 0
;PCODE: $000002E4 VOL: 0
;PCODE: $000002E5 VOL: 0
;#endif
;#if USB_INTR_CFG_CLR != 0
;    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
;#endif
;    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
;PCODE: $000002E6 VOL: 0
;PCODE: $000002E7 VOL: 0
;PCODE: $000002E8 VOL: 0
;    usbResetDataToggling();
;PCODE: $000002E9 VOL: 0
;PCODE: $000002EA VOL: 0
;PCODE: $000002EB VOL: 0
;PCODE: $000002EC VOL: 0
;PCODE: $000002ED VOL: 0
;PCODE: $000002EE VOL: 0
;PCODE: $000002EF VOL: 0
;#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
;    usbTxLen1 = USBPID_NAK;
;PCODE: $000002F0 VOL: 0
;PCODE: $000002F1 VOL: 0
;#if USB_CFG_HAVE_INTRIN_ENDPOINT3
;    usbTxLen3 = USBPID_NAK;
;#endif
;#endif
;}
;PCODE: $000002F2 VOL: 0
;PCODE: $000002F3 VOL: 0
;
;/* ------------------------------------------------------------------------- */
;
;uchar button;
;
;interrupt [TIM1_OVF] void timer1_ovf_isr(void)
; 0000 000B {
;PCODE: $000002F4 VOL: 0
;PCODE: $000002F5 VOL: 0
; 0000 000C uchar T;
; 0000 000D #asm ("sei");
;PCODE: $000002F6 VOL: 0
;	T -> R17
;PCODE: $000002F7 VOL: 0
	sei
;PCODE: $000002F8 VOL: 0
; 0000 000E 
; 0000 000F TCNT1H=0x6D84 >> 8;
;PCODE: $000002F9 VOL: 0
;PCODE: $000002FA VOL: 0
; 0000 0010 TCNT1L=0x6D84 & 0xff;
;PCODE: $000002FB VOL: 0
;PCODE: $000002FC VOL: 0
; 0000 0011 
; 0000 0012     DDRC  = 0b111;
;PCODE: $000002FD VOL: 0
;PCODE: $000002FE VOL: 0
; 0000 0013     PORTC = 0b110;
;PCODE: $000002FF VOL: 0
;PCODE: $00000300 VOL: 0
; 0000 0014     #asm ("NOP")
;PCODE: $00000301 VOL: 0
	NOP
;PCODE: $00000302 VOL: 0
; 0000 0015     T = PINB;
;PCODE: $00000303 VOL: 0
;PCODE: $00000304 VOL: 0
; 0000 0016     if ((T & 0b00001000) == 0) button = '*';
;PCODE: $00000305 VOL: 0
;PCODE: $00000306 VOL: 0
;PCODE: $00000307 VOL: 0
;PCODE: $00000308 VOL: 0
;PCODE: $00000309 VOL: 0
; 0000 0017     else if ((T & 0b00000100) == 0) button = '7';
;PCODE: $0000030A VOL: 0
;PCODE: $0000030B VOL: 0
;PCODE: $0000030C VOL: 0
;PCODE: $0000030D VOL: 0
;PCODE: $0000030E VOL: 0
;PCODE: $0000030F VOL: 0
;PCODE: $00000310 VOL: 0
; 0000 0018     else if ((T & 0b00000010) == 0) button = '4';
;PCODE: $00000311 VOL: 0
;PCODE: $00000312 VOL: 0
;PCODE: $00000313 VOL: 0
;PCODE: $00000314 VOL: 0
;PCODE: $00000315 VOL: 0
;PCODE: $00000316 VOL: 0
;PCODE: $00000317 VOL: 0
; 0000 0019     else if ((T & 0b00000001) == 0) button = '1';
;PCODE: $00000318 VOL: 0
;PCODE: $00000319 VOL: 0
;PCODE: $0000031A VOL: 0
;PCODE: $0000031B VOL: 0
;PCODE: $0000031C VOL: 0
;PCODE: $0000031D VOL: 0
;PCODE: $0000031E VOL: 0
; 0000 001A 
; 0000 001B     PORTC = 0b101;
;PCODE: $0000031F VOL: 0
;PCODE: $00000320 VOL: 0
;PCODE: $00000321 VOL: 0
;PCODE: $00000322 VOL: 0
;PCODE: $00000323 VOL: 0
;PCODE: $00000324 VOL: 0
; 0000 001C     #asm ("NOP")
;PCODE: $00000325 VOL: 0
	NOP
;PCODE: $00000326 VOL: 0
; 0000 001D     T = PINB;
;PCODE: $00000327 VOL: 0
;PCODE: $00000328 VOL: 0
; 0000 001E     if ((T & 0b00001000) == 0) button = '0';
;PCODE: $00000329 VOL: 0
;PCODE: $0000032A VOL: 0
;PCODE: $0000032B VOL: 0
;PCODE: $0000032C VOL: 0
;PCODE: $0000032D VOL: 0
; 0000 001F     else if ((T & 0b00000100) == 0) button = '8';
;PCODE: $0000032E VOL: 0
;PCODE: $0000032F VOL: 0
;PCODE: $00000330 VOL: 0
;PCODE: $00000331 VOL: 0
;PCODE: $00000332 VOL: 0
;PCODE: $00000333 VOL: 0
;PCODE: $00000334 VOL: 0
; 0000 0020     else if ((T & 0b00000010) == 0) button = '5';
;PCODE: $00000335 VOL: 0
;PCODE: $00000336 VOL: 0
;PCODE: $00000337 VOL: 0
;PCODE: $00000338 VOL: 0
;PCODE: $00000339 VOL: 0
;PCODE: $0000033A VOL: 0
;PCODE: $0000033B VOL: 0
; 0000 0021     else if ((T & 0b00000001) == 0) button = '2';
;PCODE: $0000033C VOL: 0
;PCODE: $0000033D VOL: 0
;PCODE: $0000033E VOL: 0
;PCODE: $0000033F VOL: 0
;PCODE: $00000340 VOL: 0
;PCODE: $00000341 VOL: 0
;PCODE: $00000342 VOL: 0
; 0000 0022 
; 0000 0023     PORTC = 0b011;
;PCODE: $00000343 VOL: 0
;PCODE: $00000344 VOL: 0
;PCODE: $00000345 VOL: 0
;PCODE: $00000346 VOL: 0
;PCODE: $00000347 VOL: 0
;PCODE: $00000348 VOL: 0
; 0000 0024     #asm ("NOP")
;PCODE: $00000349 VOL: 0
	NOP
;PCODE: $0000034A VOL: 0
; 0000 0025     T = PINB;
;PCODE: $0000034B VOL: 0
;PCODE: $0000034C VOL: 0
; 0000 0026     if ((T & 0b00001000) == 0) button = '#';
;PCODE: $0000034D VOL: 0
;PCODE: $0000034E VOL: 0
;PCODE: $0000034F VOL: 0
;PCODE: $00000350 VOL: 0
;PCODE: $00000351 VOL: 0
; 0000 0027     else if ((T & 0b00000100) == 0) button = '9';
;PCODE: $00000352 VOL: 0
;PCODE: $00000353 VOL: 0
;PCODE: $00000354 VOL: 0
;PCODE: $00000355 VOL: 0
;PCODE: $00000356 VOL: 0
;PCODE: $00000357 VOL: 0
;PCODE: $00000358 VOL: 0
; 0000 0028     else if ((T & 0b00000010) == 0) button = '6';
;PCODE: $00000359 VOL: 0
;PCODE: $0000035A VOL: 0
;PCODE: $0000035B VOL: 0
;PCODE: $0000035C VOL: 0
;PCODE: $0000035D VOL: 0
;PCODE: $0000035E VOL: 0
;PCODE: $0000035F VOL: 0
; 0000 0029     else if ((T & 0b00000001) == 0) button = '3';
;PCODE: $00000360 VOL: 0
;PCODE: $00000361 VOL: 0
;PCODE: $00000362 VOL: 0
;PCODE: $00000363 VOL: 0
;PCODE: $00000364 VOL: 0
;PCODE: $00000365 VOL: 0
;PCODE: $00000366 VOL: 0
; 0000 002A }
;PCODE: $00000367 VOL: 0
;PCODE: $00000368 VOL: 0
;PCODE: $00000369 VOL: 0
;PCODE: $0000036A VOL: 0
;PCODE: $0000036B VOL: 0
;PCODE: $0000036C VOL: 0
;PCODE: $0000036D VOL: 0
;PCODE: $0000036E VOL: 0
;
;struct dataexchange_t       // ќписание структуры дл€ передачи данных
;{
;   uchar b1;        // я решил дл€ примера написать структуру на 3 байта.
;//   uchar b2;        // Ќа каждый байт подцепим ногу из PORTB.  онечно это
;//   uchar b3;        // не рационально (всего то 3 бита нужно).
;};                  // Ќо в цел€х демонстрации в самый раз.
;                    // ƒл€ нагл€дности прикрутить по светодиоду и созерцать :)
;
;struct dataexchange_t pdata = {0};
;
;/* Ёти переменные хран€т статус текущей передачи */
;static uchar    currentAddress;
;static uchar    bytesRemaining;
;
;/* usbFunctionRead() вызываетс€ когда хост запрашивает порцию данных от устройства
; * ƒл€ дополнительной информации см. документацию в usbdrv.h
; */
;uchar   usbFunctionRead(uchar *data, uchar len)
; 0000 003E {
;PCODE: $0000036F VOL: 0
;PCODE: $00000370 VOL: 0
; 0000 003F     uchar j;
; 0000 0040     uchar *buffer;
; 0000 0041     if(len > bytesRemaining)
;PCODE: $00000371 VOL: 0
;PCODE: $00000372 VOL: 0
;	*data -> Y+5
;	len -> Y+4
;	j -> R17
;	*buffer -> R18,R19
;PCODE: $00000373 VOL: 0
;PCODE: $00000374 VOL: 0
;PCODE: $00000375 VOL: 0
;PCODE: $00000376 VOL: 0
; 0000 0042         len = bytesRemaining;
;PCODE: $00000377 VOL: 0
;PCODE: $00000378 VOL: 0
; 0000 0043 
; 0000 0044     buffer = (uchar*)&pdata;
;PCODE: $00000379 VOL: 0
;PCODE: $0000037A VOL: 0
;PCODE: $0000037B VOL: 0
; 0000 0045 
; 0000 0046     if(!currentAddress)        // Ќи один кусок данных еще не прочитан.
;PCODE: $0000037C VOL: 0
;PCODE: $0000037D VOL: 0
;PCODE: $0000037E VOL: 0
; 0000 0047     {                          // «аполним структуру дл€ передачи
; 0000 0048         pdata.b1 = button;
;PCODE: $0000037F VOL: 0
;PCODE: $00000380 VOL: 0
; 0000 0049         button = 0xFF;
;PCODE: $00000381 VOL: 0
;PCODE: $00000382 VOL: 0
; 0000 004A     }
; 0000 004B 
; 0000 004C     for(j=0; j<len; j++)
;PCODE: $00000383 VOL: 0
;PCODE: $00000384 VOL: 0
;PCODE: $00000385 VOL: 0
;PCODE: $00000386 VOL: 0
;PCODE: $00000387 VOL: 0
;PCODE: $00000388 VOL: 0
;PCODE: $00000389 VOL: 0
;PCODE: $0000038A VOL: 0
;PCODE: $0000038B VOL: 0
;PCODE: $0000038C VOL: 0
; 0000 004D         data[j] = buffer[j+currentAddress];
;PCODE: $0000038D VOL: 0
;PCODE: $0000038E VOL: 0
;PCODE: $0000038F VOL: 0
;PCODE: $00000390 VOL: 0
;PCODE: $00000391 VOL: 0
;PCODE: $00000392 VOL: 0
;PCODE: $00000393 VOL: 0
;PCODE: $00000394 VOL: 0
;PCODE: $00000395 VOL: 0
;PCODE: $00000396 VOL: 0
;PCODE: $00000397 VOL: 0
;PCODE: $00000398 VOL: 0
;PCODE: $00000399 VOL: 0
;PCODE: $0000039A VOL: 0
;PCODE: $0000039B VOL: 0
;PCODE: $0000039C VOL: 0
;PCODE: $0000039D VOL: 0
;PCODE: $0000039E VOL: 0
;PCODE: $0000039F VOL: 0
; 0000 004F currentAddress += len;
;PCODE: $000003A0 VOL: 0
;PCODE: $000003A1 VOL: 0
;PCODE: $000003A2 VOL: 0
;PCODE: $000003A3 VOL: 0
; 0000 0050     bytesRemaining -= len;
;PCODE: $000003A4 VOL: 0
;PCODE: $000003A5 VOL: 0
;PCODE: $000003A6 VOL: 0
;PCODE: $000003A7 VOL: 0
; 0000 0051     return len;
;PCODE: $000003A8 VOL: 0
;PCODE: $000003A9 VOL: 0
;PCODE: $000003AA VOL: 0
;PCODE: $000003AB VOL: 0
; 0000 0052 }
;PCODE: $000003AC VOL: 0
;
;
;/* usbFunctionWrite() вызываетс€ когда хост отправл€ет порцию данных к устройству
; * ƒл€ дополнительной информации см. документацию в usbdrv.h
; */
;uchar   usbFunctionWrite(uchar *data, uchar len)
; 0000 0059 {
;PCODE: $000003AD VOL: 0
;PCODE: $000003AE VOL: 0
; 0000 005A     uchar j;
; 0000 005B     uchar *buffer;
; 0000 005C     if(bytesRemaining == 0)
;PCODE: $000003AF VOL: 0
;PCODE: $000003B0 VOL: 0
;	*data -> Y+5
;	len -> Y+4
;	j -> R17
;	*buffer -> R18,R19
;PCODE: $000003B1 VOL: 0
;PCODE: $000003B2 VOL: 0
;PCODE: $000003B3 VOL: 0
; 0000 005D         return 1;               /* конец передачи */
;PCODE: $000003B4 VOL: 0
;PCODE: $000003B5 VOL: 0
;PCODE: $000003B6 VOL: 0
;PCODE: $000003B7 VOL: 0
; 0000 005E 
; 0000 005F     if(len > bytesRemaining)
;PCODE: $000003B8 VOL: 0
;PCODE: $000003B9 VOL: 0
;PCODE: $000003BA VOL: 0
;PCODE: $000003BB VOL: 0
;PCODE: $000003BC VOL: 0
; 0000 0060         len = bytesRemaining;
;PCODE: $000003BD VOL: 0
;PCODE: $000003BE VOL: 0
; 0000 0061 
; 0000 0062     buffer = (uchar*)&pdata;
;PCODE: $000003BF VOL: 0
;PCODE: $000003C0 VOL: 0
;PCODE: $000003C1 VOL: 0
; 0000 0063 
; 0000 0064     for(j=0; j<len; j++)
;PCODE: $000003C2 VOL: 0
;PCODE: $000003C3 VOL: 0
;PCODE: $000003C4 VOL: 0
;PCODE: $000003C5 VOL: 0
;PCODE: $000003C6 VOL: 0
;PCODE: $000003C7 VOL: 0
;PCODE: $000003C8 VOL: 0
;PCODE: $000003C9 VOL: 0
;PCODE: $000003CA VOL: 0
; 0000 0065         buffer[j+currentAddress] = data[j];
;PCODE: $000003CB VOL: 0
;PCODE: $000003CC VOL: 0
;PCODE: $000003CD VOL: 0
;PCODE: $000003CE VOL: 0
;PCODE: $000003CF VOL: 0
;PCODE: $000003D0 VOL: 0
;PCODE: $000003D1 VOL: 0
;PCODE: $000003D2 VOL: 0
;PCODE: $000003D3 VOL: 0
;PCODE: $000003D4 VOL: 0
;PCODE: $000003D5 VOL: 0
;PCODE: $000003D6 VOL: 0
;PCODE: $000003D7 VOL: 0
;PCODE: $000003D8 VOL: 0
;PCODE: $000003D9 VOL: 0
;PCODE: $000003DA VOL: 0
;PCODE: $000003DB VOL: 0
; 0000 0067 currentAddress += len;
;PCODE: $000003DC VOL: 0
;PCODE: $000003DD VOL: 0
;PCODE: $000003DE VOL: 0
;PCODE: $000003DF VOL: 0
; 0000 0068     bytesRemaining -= len;
;PCODE: $000003E0 VOL: 0
;PCODE: $000003E1 VOL: 0
;PCODE: $000003E2 VOL: 0
;PCODE: $000003E3 VOL: 0
; 0000 0069 
; 0000 006A //    if(bytesRemaining == 0)     // ¬се данные получены
; 0000 006B //    {                           // ¬ыставим значени€ на PORTB
; 0000 006C //        if ( pdata.b1 )
; 0000 006D //            PORTB |= _BV(1);
; 0000 006E //        else
; 0000 006F //            PORTB &= ~_BV(1);
; 0000 0070 //
; 0000 0071 //
; 0000 0072 //        if ( pdata.b2 )
; 0000 0073 //            PORTB |= _BV(2);
; 0000 0074 //        else
; 0000 0075 //            PORTB &= ~_BV(2);
; 0000 0076 //
; 0000 0077 //
; 0000 0078 //        if ( pdata.b3 )
; 0000 0079 //            PORTB |= _BV(3);
; 0000 007A //        else
; 0000 007B //            PORTB &= ~_BV(3);
; 0000 007C //    }
; 0000 007D 
; 0000 007E     return bytesRemaining == 0; /* 0 означает, что есть еще данные */
;PCODE: $000003E4 VOL: 0
;PCODE: $000003E5 VOL: 0
;PCODE: $000003E6 VOL: 0
;PCODE: $000003E7 VOL: 0
;PCODE: $000003E8 VOL: 0
;PCODE: $000003E9 VOL: 0
; 0000 007F }
;PCODE: $000003EA VOL: 0
;
;/* ------------------------------------------------------------------------- */
;
;usbMsgLen_t usbFunctionSetup(uchar data[8])
; 0000 0084 {
;PCODE: $000003EB VOL: 0
;PCODE: $000003EC VOL: 0
; 0000 0085 usbRequest_t    *rq = (void *)data;
; 0000 0086 
; 0000 0087     if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID устройство */
;PCODE: $000003ED VOL: 0
;PCODE: $000003EE VOL: 0
;	data -> Y+2
;	*rq -> R16,R17
;PCODE: $000003EF VOL: 0
;PCODE: $000003F0 VOL: 0
;PCODE: $000003F1 VOL: 0
;PCODE: $000003F2 VOL: 0
;PCODE: $000003F3 VOL: 0
;PCODE: $000003F4 VOL: 0
;PCODE: $000003F5 VOL: 0
; 0000 0088         if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
;PCODE: $000003F6 VOL: 0
;PCODE: $000003F7 VOL: 0
;PCODE: $000003F8 VOL: 0
;PCODE: $000003F9 VOL: 0
; 0000 0089             // у нас только одна разновидность репорта, можем игнорировать report-ID
; 0000 008A             bytesRemaining = sizeof(struct dataexchange_t);
;PCODE: $000003FA VOL: 0
;PCODE: $000003FB VOL: 0
; 0000 008B             currentAddress = 0;
;PCODE: $000003FC VOL: 0
;PCODE: $000003FD VOL: 0
; 0000 008C             return USB_NO_MSG;  // используем usbFunctionRead() дл€ отправки данных хосту
;PCODE: $000003FE VOL: 0
;PCODE: $000003FF VOL: 0
;PCODE: $00000400 VOL: 0
;PCODE: $00000401 VOL: 0
; 0000 008D         }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
;PCODE: $00000402 VOL: 0
;PCODE: $00000403 VOL: 0
;PCODE: $00000404 VOL: 0
;PCODE: $00000405 VOL: 0
;PCODE: $00000406 VOL: 0
; 0000 008E             // у нас только одна разновидность репорта, можем игнорировать report-ID
; 0000 008F             bytesRemaining = sizeof(struct dataexchange_t);
;PCODE: $00000407 VOL: 0
;PCODE: $00000408 VOL: 0
; 0000 0090             currentAddress = 0;
;PCODE: $00000409 VOL: 0
;PCODE: $0000040A VOL: 0
; 0000 0091             return USB_NO_MSG;  // используем usbFunctionWrite() дл€ получени€ данных от хоста
;PCODE: $0000040B VOL: 0
;PCODE: $0000040C VOL: 0
;PCODE: $0000040D VOL: 0
;PCODE: $0000040E VOL: 0
; 0000 0092         }
; 0000 0093     }else{
;PCODE: $0000040F VOL: 0
;PCODE: $00000410 VOL: 0
;PCODE: $00000411 VOL: 0
;PCODE: $00000412 VOL: 0
; 0000 0094         /* остальные запросы мы просто игнорируем */
; 0000 0095     }
;PCODE: $00000413 VOL: 0
; 0000 0096     return 0;
;PCODE: $00000414 VOL: 0
;PCODE: $00000415 VOL: 0
;PCODE: $00000416 VOL: 0
;PCODE: $00000417 VOL: 0
; 0000 0097 }
;PCODE: $00000418 VOL: 0
;/* ------------------------------------------------------------------------- */
;
;void main(void)
; 0000 009B {
;PCODE: $00000419 VOL: 0
; 0000 009C     uchar i = 0;
; 0000 009D // Port B initialization
; 0000 009E // Function: Bit7=In Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
; 0000 009F DDRB=(0<<DDB7) | (0<<DDB6) | (0<<DDB5) | (0<<DDB4) | (0<<DDB3) | (0<<DDB2) | (0<<DDB1) | (0<<DDB0);
;	i -> R17
;PCODE: $0000041A VOL: 0
;PCODE: $0000041B VOL: 0
;PCODE: $0000041C VOL: 0
;PCODE: $0000041D VOL: 0
; 0000 00A0 // State: Bit7=T Bit6=T Bit5=T Bit4=T Bit3=P Bit2=P Bit1=P Bit0=P
; 0000 00A1 PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (1<<PORTB3) | (1<<PORTB2) | (1<<PORTB1) | (1<<PORTB0);
;PCODE: $0000041E VOL: 0
;PCODE: $0000041F VOL: 0
; 0000 00A2 
; 0000 00A3 // Port C initialization
; 0000 00A4 DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (1<<DDC2) | (1<<DDC1) | (1<<DDC0);
;PCODE: $00000420 VOL: 0
;PCODE: $00000421 VOL: 0
; 0000 00A5 // State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
; 0000 00A6 PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (1<<PORTC2) | (1<<PORTC1) | (1<<PORTC0);
;PCODE: $00000422 VOL: 0
;PCODE: $00000423 VOL: 0
; 0000 00A7 
; 0000 00A8 // Timer/Counter 1 initialization
; 0000 00A9 // Clock source: System Clock
; 0000 00AA // Clock value: 1000,000 kHz
; 0000 00AB // Mode: Normal top=0xFFFF
; 0000 00AC // OC1A output: Disconnected
; 0000 00AD // OC1B output: Disconnected
; 0000 00AE // Noise Canceler: Off
; 0000 00AF // Input Capture on Falling Edge
; 0000 00B0 // Timer Period: 25 ms
; 0000 00B1 // Timer1 Overflow Interrupt: On
; 0000 00B2 // Input Capture Interrupt: Off
; 0000 00B3 // Compare A Match Interrupt: Off
; 0000 00B4 // Compare B Match Interrupt: Off
; 0000 00B5 TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<WGM11) | (0<<WGM10);
;PCODE: $00000424 VOL: 0
;PCODE: $00000425 VOL: 0
; 0000 00B6 TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (0<<WGM12) | (0<<CS12) | (1<<CS11) | (0<<CS10);
;PCODE: $00000426 VOL: 0
;PCODE: $00000427 VOL: 0
; 0000 00B7 TCNT1H=0x9E;
;PCODE: $00000428 VOL: 0
;PCODE: $00000429 VOL: 0
; 0000 00B8 TCNT1L=0x58;
;PCODE: $0000042A VOL: 0
;PCODE: $0000042B VOL: 0
; 0000 00B9 ICR1H=0x00;
;PCODE: $0000042C VOL: 0
;PCODE: $0000042D VOL: 0
; 0000 00BA ICR1L=0x00;
;PCODE: $0000042E VOL: 0
;PCODE: $0000042F VOL: 0
; 0000 00BB OCR1AH=0x00;
;PCODE: $00000430 VOL: 0
;PCODE: $00000431 VOL: 0
; 0000 00BC OCR1AL=0x00;
;PCODE: $00000432 VOL: 0
;PCODE: $00000433 VOL: 0
; 0000 00BD OCR1BH=0x00;
;PCODE: $00000434 VOL: 0
;PCODE: $00000435 VOL: 0
; 0000 00BE OCR1BL=0x00;
;PCODE: $00000436 VOL: 0
;PCODE: $00000437 VOL: 0
; 0000 00BF 
; 0000 00C0 // USART initialization
; 0000 00C1 // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0000 00C2 // USART Receiver: Off
; 0000 00C3 // USART Transmitter: On
; 0000 00C4 // USART Mode: Asynchronous
; 0000 00C5 // USART Baud Rate: 9600
; 0000 00C6 UCSRA=(0<<RXC) | (0<<TXC) | (0<<UDRE) | (0<<FE) | (0<<DOR) | (0<<UPE) | (0<<U2X) | (0<<MPCM);
;PCODE: $00000438 VOL: 0
;PCODE: $00000439 VOL: 0
; 0000 00C7 UCSRB=(0<<RXCIE) | (0<<TXCIE) | (0<<UDRIE) | (0<<RXEN) | (1<<TXEN) | (0<<UCSZ2) | (0<<RXB8) | (0<<TXB8);
;PCODE: $0000043A VOL: 0
;PCODE: $0000043B VOL: 0
; 0000 00C8 UCSRC=(1<<URSEL) | (0<<UMSEL) | (0<<UPM1) | (0<<UPM0) | (0<<USBS) | (1<<UCSZ1) | (1<<UCSZ0) | (0<<UCPOL);
;PCODE: $0000043C VOL: 0
;PCODE: $0000043D VOL: 0
; 0000 00C9 UBRRH=0x00;
;PCODE: $0000043E VOL: 0
;PCODE: $0000043F VOL: 0
; 0000 00CA UBRRL=0x33;
;PCODE: $00000440 VOL: 0
;PCODE: $00000441 VOL: 0
; 0000 00CB 
; 0000 00CC // Analog Comparator initialization
; 0000 00CD // Analog Comparator: Off
; 0000 00CE // The Analog Comparator's positive input is
; 0000 00CF // connected to the AIN0 pin
; 0000 00D0 // The Analog Comparator's negative input is
; 0000 00D1 // connected to the AIN1 pin
; 0000 00D2 ACSR=(1<<ACD) | (0<<ACBG) | (0<<ACO) | (0<<ACI) | (0<<ACIE) | (0<<ACIC) | (0<<ACIS1) | (0<<ACIS0);
;PCODE: $00000442 VOL: 0
;PCODE: $00000443 VOL: 0
; 0000 00D3 SFIOR=(0<<ACME);
;PCODE: $00000444 VOL: 0
;PCODE: $00000445 VOL: 0
; 0000 00D4 
; 0000 00D5 // Timer(s)/Counter(s) Interrupt(s) initialization
; 0000 00D6 TIMSK=(0<<OCIE2) | (0<<TOIE2) | (0<<TICIE1) | (0<<OCIE1A) | (0<<OCIE1B) | (1<<TOIE1) | (0<<TOIE0);
;PCODE: $00000446 VOL: 0
;PCODE: $00000447 VOL: 0
; 0000 00D7 
; 0000 00D8     usbInit();
;PCODE: $00000448 VOL: 0
; 0000 00D9     usbDeviceDisconnect();  // принудительно отключаемс€ от хоста, так делать можно только при выключенных прерывани€х!
;PCODE: $00000449 VOL: 0
;PCODE: $0000044A VOL: 0
; 0000 00DA 
; 0000 00DB     while(--i){             // пауза > 250 ms
;PCODE: $0000044B VOL: 0
;PCODE: $0000044C VOL: 0
;PCODE: $0000044D VOL: 0
;PCODE: $0000044E VOL: 0
; 0000 00DC         _delay_ms(1);
;PCODE: $0000044F VOL: 0
;PCODE: $00000450 VOL: 0
;PCODE: $00000451 VOL: 0
; 0000 00DD     }
;PCODE: $00000452 VOL: 0
;PCODE: $00000453 VOL: 0
; 0000 00DE 
; 0000 00DF     usbDeviceConnect();     // подключаемс€
;PCODE: $00000454 VOL: 0
;PCODE: $00000455 VOL: 0
; 0000 00E0 
; 0000 00E1     #asm ("sei");                  // разрешаем прерывани€
;PCODE: $00000456 VOL: 0
	sei
;PCODE: $00000457 VOL: 0
; 0000 00E2 
; 0000 00E3     while(1){                // главный цикл программы
;PCODE: $00000458 VOL: 0
; 0000 00E4         usbPoll();          // эту функцию надо регул€рно вызывать с главного цикла, максимальна€ задержка между вызовам ...
;PCODE: $00000459 VOL: 0
; 0000 00E5         if (button != 0) putchar (button);
;PCODE: $0000045A VOL: 0
;PCODE: $0000045B VOL: 0
;PCODE: $0000045C VOL: 0
;PCODE: $0000045D VOL: 0
; 0000 00E6         button = 0;
;PCODE: $0000045E VOL: 0
;PCODE: $0000045F VOL: 0
; 0000 00E7         delay_ms (10);
;PCODE: $00000460 VOL: 0
;PCODE: $00000461 VOL: 0
;PCODE: $00000462 VOL: 0
; 0000 00E8     }
;PCODE: $00000463 VOL: 0
;PCODE: $00000464 VOL: 0
; 0000 00E9 }
;PCODE: $00000465 VOL: 0
;PCODE: $00000466 VOL: 0
;PCODE: $00000467 VOL: 0
;/* ------------------------------------------------------------------------- */
